#!/usr/bin/env python
# coding: utf-8

# #### Update summa parameter values based on Ostrich generated multiplier values
# 1. Read input and output arguments from control_active.txt.
# 2. Read summa param names and multiplier values.
# 3. Update summa param values.

# import module
import os
import numpy as np
import shutil, sys
import netCDF4 as nc
import argparse

def process_command_line():
    '''Parse the commandline'''
    parser = argparse.ArgumentParser(description='Script to icalculate model evaluation statistics.')
    parser.add_argument('controlFile', help='path of the overall control file.')
    args = parser.parse_args()
    return(args)

# Function to extract a given setting from the configuration file
def read_from_control(control_file, setting):
    
    # Open 'control_active.txt' and locate the line with setting
    with open(control_file) as ff:
        for line in ff:
            line = line.strip()
            if line.startswith(setting):
                break
    # Extract the setting's value
    substring = line.split('|',1)[1].split('#',1)[0].strip() 
    # Return this value    
    return substring
       
# Function to extract a given setting from the summa and mizuRoute manager/control files
def read_from_summa_route_control(control_file, setting):

    # Open fileManager.txt or route_control and locate the line with setting
    with open(control_file) as ff:
        for line in ff:
            line = line.strip()
            if line.startswith(setting):
                break
    # Extract the setting's value
    substring = line.split('!',1)[0].strip().split(None,1)[1].strip("'")
    # Return this value    
    return substring

# main
if __name__ == '__main__':
    
    # an example: python calc_sim_stats.py ../control_active.txt

    # ---------------------------- Preparation -------------------------------
    # --- process command line --- 
    # check args
    if len(sys.argv) != 2:
        print("Usage: %s <control_file>" % sys.argv[0])
        sys.exit(0)
    # otherwise continue
    args = process_command_line()    
    control_file = args.controlFile
    
    # #### 1. Preparation ####
    # read paths from control_file.
    root_path = read_from_control(control_file, 'root_path')
    domain_name = read_from_control(control_file, 'domain_name')
    complexity_level = read_from_control(control_file, 'complexity_level')        
    domain_path = os.path.join(root_path, complexity_level+'_'+domain_name)

    # read new hydrologic model path from control_file.
    model_dst_path = read_from_control(control_file, 'model_dst_path')
    if model_dst_path == 'default':
        model_dst_path = os.path.join(domain_path, 'model')

    # read summa settings and fileManager paths from control_file.
    summa_settings_relpath = read_from_control(control_file, 'summa_settings_relpath')
    summa_settings_path = os.path.join(model_dst_path, summa_settings_relpath)
    summa_filemanager = read_from_control(control_file, 'summa_filemanager')
    summa_filemanager = os.path.join(summa_settings_path, summa_filemanager)

    # read calib path from control_file.
    calib_path = read_from_control(control_file, 'calib_path')
    if calib_path == 'default':
        calib_path = os.path.join(domain_path, 'calib')
    calib_tpl_path = os.path.join(calib_path, 'tpl')
    # -----------------------------------------------------------------------

    # # #### 1. Read input and output arguments
    # a list of parameters that are not calib by multiplier, but directly on param values.
    direct_param_list = ['']  

    # (input) multiplier template file generated by 4_prepare_multp_bounds.ipynb.
    multp_tpl = read_from_control(control_file, 'multp_tpl')
    multp_tpl = os.path.join(calib_tpl_path, multp_tpl)

    # (input) multiplier value file generated by Ostrich
    multp_txt = read_from_control(control_file, 'multp_value')
    multp_txt = os.path.join(calib_path, multp_txt)

    # (output) summa utilized param file
    trialParamFile = read_from_summa_route_control(summa_filemanager, 'trialParamFile')
    trialParamFile = os.path.join(summa_settings_path, trialParamFile)

    # (input) summa a priori param file 
    trialParamFile_priori = trialParamFile.split('.nc')[0] + '.priori.nc' # a priori param file
    trialParamFile_priori = os.path.join(summa_settings_path, trialParamFile_priori)

    # #### 2. Read summa param names and multiplier values
    multp_names = np.loadtxt(multp_tpl, dtype='str')
    param_names = [x.replace('_multp','') for x in multp_names] # derive param name by removing substring '_multp'
    multp_values = np.loadtxt(multp_txt)

    # #### 3. Update summa param values
    # copy trialParamFile_priori to be the base of trialParamFile.
    shutil.copy(trialParamFile_priori, trialParamFile)

    # update param values in trialParamFile.
    with nc.Dataset(trialParamFile_priori, 'r') as src:
        with nc.Dataset(trialParamFile, 'r+') as dst:

            for i in range(len(param_names)):
                param_name = param_names[i]

                # update all params except 'thickness'
                if (param_name != 'thickness') and param_name in dst.variables.keys():  

                    # update param values
                    if not param_name in direct_param_list:# new_value = multipler * default_value
                        param_ma_priori = src.variables[param_name][:]               # priori param value mask array 
                        param_value     = param_ma_priori.data * multp_values[i]     # update param value mask array
                        dst.variables[param_name][:] = np.ma.array(param_value, \
                                                                   mask=np.ma.getmask(param_ma_priori), \
                                                                   fill_value=param_ma_priori.get_fill_value())
                    elif param_name in direct_param_list: # new_value = Ostrich value
                        param_ma_priori = src.variables[param_name][:]                          # priori param value mask array 
                        param_value     = np.ones_like(param_ma_priori.data) * multp_values[i]  # update param value mask array
                        dst.variables[param_name][:] = np.ma.array(param_value, \
                                                                   mask=np.ma.getmask(param_ma_priori), \
                                                                   fill_value=param_ma_priori.get_fill_value())                   

#                     # if param is 'theta_sat', update other four soil variables using a priori param value fractions.
#                     if param_name == 'theta_sat':
#                         param_ma_priori  = src.variables[param_name][:]
#                         param_ma = dst.variables[param_name][:]

#                         for add_param in ['theta_res', 'critSoilWilting', 'critSoilTranspire', 'fieldCapacity']:
#                             add_param_ma_priori  = src.variables[add_param][:]
#                             fraction =  np.divide(add_param_ma_priori.data, param_ma_priori.data) # fraction based on priori variable values
#                             add_param_value = param_ma.data * fraction
#                             dst.variables[add_param][:]= np.ma.array(add_param_value, \
#                                                                      mask=np.ma.getmask(add_param_ma_priori), \
#                                                                      fill_value=add_param_ma_priori.get_fill_value())
                
                # exist code if this parameter does not exist in trialParam.nc.
                elif (param_name != 'thickness') and not (param_name in dst.variables.keys()):
                    print('Unable to update parameter %s beucase it does not exist in trialParam.nc'%(param_name))
                    sys.exit(0)
                    
            # After updating all parameters, update 'thickness' if it exists. 
            # Actually, use 'thickness' to calculate TopCanopyHeight.
            if 'thickness' in param_names:
                tied_param_name   = 'heightCanopyBottom'
                target_param_name = 'heightCanopyTop'

                # update TopCanopyHeight
                TH_param_ma_priori = src.variables[target_param_name][:]         # priori TopCanopyHeight mask array 
                BH_param_ma_priori = src.variables[tied_param_name][:]           # priori BottomCanopyHeight mask array 
                BH_param_ma        = dst.variables[tied_param_name][:]           # updated BottomCanopyHeight mask array
                param_value        = BH_param_ma.data + \
                (TH_param_ma_priori.data-BH_param_ma_priori.data)*multp_values[i]    # updated TopCanopyHeight values
                dst.variables[target_param_name][:] = np.ma.array(param_value, \
                                                                  mask=np.ma.getmask(TH_param_ma_priori), \
                                                                  fill_value=TH_param_ma_priori.get_fill_value())

